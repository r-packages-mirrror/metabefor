% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/explode_vector_to_values.R
\name{explode_vector_to_values}
\alias{explode_vector_to_values}
\title{Explode a vector to values}
\usage{
explode_vector_to_values(
  studies,
  entityId,
  prefix = NULL,
  values = 0:1,
  valueDict = NULL
)
}
\arguments{
\item{studies}{The \code{studies} object (as produced
by \code{\link[=rxs_parseExtractionScripts]{rxs_parseExtractionScripts()}}).}

\item{entityId}{The entity identifier.}

\item{prefix}{The prefix to use to create the new entity names.}

\item{values}{The values to store to represent, respectively, that a value
did not or did occur in the original vector.}

\item{valueDict}{Optionally, a dictionary that will be used to convert
values to entity identifiers (i.e. the bit appended to the \code{prefix}). If
nothing is specified, the original values will be sanitized and used.}
}
\value{
Invisibly, the studies object. Note that the study trees will be
changed in place given \code{data.tree}'s pass-by-reference logic; so you can
discard the result.
}
\description{
This function takes a \code{studies} object (as produced
by \code{\link[=rxs_parseExtractionScripts]{rxs_parseExtractionScripts()}}) and processes all study
trees, looking for the values stored in the entity with the specified
identifier (this cannot be a clustering entity or a clustered entity;
see the definitions at
\url{https://r-packages.gitlab.io/metabefor/articles/definitions.html}),
compiling a list of all occurring values, and then adds new entities
for each occurring value, with new values (by default, \code{0} and \code{1})
indicating whether that value occurred in the original vector for a
given entity.
}
\details{
For example, imagine the following situation. We want to process an entity
called \code{exampleVector} in three study trees. In the first study tree,
that entity contains the value \code{c("a", "b")}; in the second study tree, it
contains \code{c("a", "c", "d")}; and in the third study tree, it doesn't exist.
If we would then run if this function is run with its default arguments,
in all three study trees, four new entities will be added, \code{exampleVector_a},
\code{exampleVector_b}, \code{exampleVector_c}, and \code{exampleVector_d}. For the first
study, the values would be, respectively, \code{1}, \code{1}, \code{0}, and \code{0}; for the
second study, they would be \code{1}, \code{0}, \code{1}, and \code{1}; and for the third
study, they would all be \code{0} (see the example).
}
\examples{
### Create fake 'studies' object
studies <-
  list(rxsTrees = list());
class(studies) <-
  "rxs_parsedExtractionScripts";
  
### Add three fake studies
studies$rxsTrees <-
  list(study1 = data.tree::Node$new("study"),
       study2 = data.tree::Node$new("study"),
       study3 = data.tree::Node$new("study"));

### Add values for an entity with id 'exampleVector'
studies$rxsTrees$study1$AddChild(
  "exampleVector", value=c("a", "b")
);
studies$rxsTrees$study2$AddChild(
  "exampleVector", value=c("a", "c", "d")
);

### Explore this vector
explode_vector_to_values(studies, "exampleVector");

### View the results for the first study
studies$rxsTrees$study1$Get(
  "value",
  filterFun = function(node) {
    return(grepl("exampleVector_", node$name));
  },
  simplify = FALSE
);
}
